package eu.eventstorm.sql;

import static eu.eventstorm.sql.M3RepositoryException.Type.EXECUTE_QUERY;
import static eu.eventstorm.sql.M3RepositoryException.Type.INSERT_GENERATED_KEYS;
import static eu.eventstorm.sql.M3RepositoryException.Type.PREPARED_STATEMENT_SETTER;
import static eu.eventstorm.sql.M3RepositoryException.Type.RESULT_SET_MAPPER;
import static eu.eventstorm.sql.M3RepositoryException.Type.RESULT_SET_NEXT;

import java.sql.PreparedStatement;
import java.sql.ResultSet;
import java.sql.SQLException;
import java.util.List;
import java.util.Spliterator;
import java.util.function.Consumer;
import java.util.stream.Stream;
import java.util.stream.StreamSupport;

import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import com.google.common.collect.ImmutableList;

import eu.eventstorm.sql.builder.DeleteBuilder;
import eu.eventstorm.sql.builder.InsertBuilder;
import eu.eventstorm.sql.builder.SelectBuilder;
import eu.eventstorm.sql.builder.UpdateBuilder;
import eu.eventstorm.sql.desc.SqlColumn;
import eu.eventstorm.sql.desc.SqlPrimaryKey;
import eu.eventstorm.sql.desc.SqlSingleColumn;
import eu.eventstorm.sql.desc.SqlTable;
import eu.eventstorm.sql.domain.Page;
import eu.eventstorm.sql.domain.PageImpl;
import eu.eventstorm.sql.domain.Pageable;
import eu.eventstorm.sql.expression.AggregateFunction;
import eu.eventstorm.sql.id.SequenceGenerator4Long;
import eu.eventstorm.sql.jdbc.InsertMapper;
import eu.eventstorm.sql.jdbc.InsertMapperWithAutoIncrement;
import eu.eventstorm.sql.jdbc.M3PreparedStatementSetterException;
import eu.eventstorm.sql.jdbc.MapperException;
import eu.eventstorm.sql.jdbc.PreparedStatementSetter;
import eu.eventstorm.sql.jdbc.ResultSetMapper;
import eu.eventstorm.sql.jdbc.ResultSetMappers;
import eu.eventstorm.sql.jdbc.UpdateMapper;
import eu.eventstorm.sql.tx.TransactionContext;

/**
 * Repository pattern, subclasses will be generated by apt.
 *
 * @author <a href="mailto:jacques.militello@gmail.com">Jacques Militello</a>
 */
public abstract class Repository {

    private static final Logger LOGGER = LoggerFactory.getLogger(Repository.class);

    private final Database database;

    public Repository(Database database) {
        this.database = database;
    }

    protected Database database() {
        return this.database;
    }

    protected final SelectBuilder select(ImmutableList<SqlColumn> columns) {
        return new SelectBuilder(this.database, columns);
    }

    protected final SelectBuilder select(SqlColumn... columns) {
        return new SelectBuilder(this.database, ImmutableList.copyOf(columns));
    }

    protected final SelectBuilder select(AggregateFunction aggregateFunction) {
        return new SelectBuilder(this.database, aggregateFunction);
    }

    protected final InsertBuilder insert(SqlTable table, ImmutableList<SqlPrimaryKey> keys,
                                         ImmutableList<SqlSingleColumn> columns) {
        return new InsertBuilder(this.database, table, keys, columns);
    }

    protected final UpdateBuilder update(SqlTable table, ImmutableList<SqlSingleColumn> columns, ImmutableList<SqlPrimaryKey> keys) {
        return new UpdateBuilder(this.database, table, columns, keys);
    }

    protected final DeleteBuilder delete(SqlTable table) {
        return new DeleteBuilder(this.database, table);
    }

    protected final <T> T executeSelect(String sql, PreparedStatementSetter pss, ResultSetMapper<T> mapper) {
    	PreparedStatement ps = database.transactionManager().context().read(sql);
        try {
            pss.set(ps);
        } catch (SQLException cause) {
            throw new M3RepositoryException(PREPARED_STATEMENT_SETTER, cause);
        }
        try (ResultSet rs = ps.executeQuery()) {
            return map(rs, mapper, this.database.dialect());
        } catch (SQLException cause) {
            throw new M3RepositoryException(EXECUTE_QUERY, cause);
        }
    }

    private static <T> T map(ResultSet rs, ResultSetMapper<T> mapper, Dialect dialect) {
    	boolean value;
    	
    	try {
			value = rs.next();
		} catch (SQLException cause) {
			throw new M3RepositoryException(RESULT_SET_NEXT, cause);
		}
    	
    	if (value) {
            try {
				return mapper.map(dialect, rs);
			} catch (SQLException cause) {
				throw new M3RepositoryException(RESULT_SET_MAPPER, cause);
			}
        } else {
            return null;
        }
    }
    
    protected final <E> void executeBatchInsert(String sql, InsertMapper<E> im, List<E> pojos,
                                                SequenceGenerator4Long generator) {

        if (LOGGER.isDebugEnabled()) {
            LOGGER.debug("INSERT : [{}], pojo=[{}]", sql, pojos);
        }

        PreparedStatement ps =  database.transactionManager().context().write(sql);
        for (E po : pojos) {
            try {
                im.insert(ps, po);
            } catch (SQLException cause) {
                throw new MapperException(sql, im, pojos, cause);
            }
            try {
                ps.addBatch();
            } catch (SQLException cause) {
                throw new MapperException(sql, im, pojos, cause);
            }

        }

        int[] vals;

        try {
            vals = ps.executeBatch();
        } catch (SQLException cause) {
            throw new EventstormSqlException("executeBatchInsert: cannot Insert", cause);
        }

        if (vals.length != pojos.size()) {
            throw new EventstormSqlException(
                    "executeBatchInsert: should update " + pojos.size() + " elements but updated " + vals.length);
        }
        for (int value : vals) {
            if (value == 0) {
                throw new EventstormSqlException("executeBatchInsert: failed to insert one or more records");
            }
        }

    }

    protected final <T> Stream<T> stream(String sql, PreparedStatementSetter pss, ResultSetMapper<T> mapper) {

    	TransactionContext tc = database.transactionManager().context();
    	
        PreparedStatement ps = tc.read(sql);

        if (LOGGER.isDebugEnabled()) {
            LOGGER.debug("stream : [{}]", sql);
        }

        try {
            pss.set(ps);
        } catch (SQLException cause) {
            throw new M3PreparedStatementSetterException(sql, pss, cause);
        }

        ResultSet rs;
        try {
            rs = ps.executeQuery();
        } catch (SQLException cause) {
        	throw new M3RepositoryException(EXECUTE_QUERY, cause);
        }

        tc.addHook(() -> {
            try {
                rs.close();
            } catch (SQLException cause) {
                LOGGER.warn("Hook -> failed to closed resultset for stream({})", sql);
            }
        });

        return StreamSupport.stream(new Spliterator<T>() {
            @Override
            public boolean tryAdvance(Consumer<? super T> action) {
                try {
                    if (!rs.next()) {
                        return false;
                    }
                } catch (SQLException cause) {
                	throw new M3RepositoryException(RESULT_SET_NEXT, cause);
                }
                try {
                    action.accept(mapper.map(database.dialect(), rs));
                } catch (SQLException cause) {
                	throw new M3RepositoryException(RESULT_SET_MAPPER, cause);
                }
                return true;
            }

            @Override
            public Spliterator<T> trySplit() {
                return null;
            }

            @Override
            public long estimateSize() {
                return 0;
            }

            @Override
            public int characteristics() {
                return 0;
            }
        }, false);

    }

    protected <E> void executeInsert(String sql, InsertMapper<E> im, E pojo) {
        PreparedStatement ps = database.transactionManager().context().write(sql);
        try {
            im.insert(ps, pojo);
        } catch (SQLException cause) {
            throw new MapperException(sql, im, pojo, cause);
        }
        int val;
        try {
            val = ps.executeUpdate();
        } catch (SQLException cause) {
            throw new EventstormSqlException("executeInsert: cannot Insert", cause);
        }
        if (val != 1) {
            throw new EventstormSqlException("executeInsert: should update 1 element but updated [" + val + "]");
        }
    }

    protected <E> void executeUpdate(String sql, UpdateMapper<E> um, E pojo) {

        if (LOGGER.isDebugEnabled()) {
            LOGGER.debug("UPDATE : [{}], pojo=[{}]", sql, pojo);
        }

        PreparedStatement ps = database.transactionManager().context().write(sql);

        try {
            um.update(ps, pojo);
        } catch (SQLException cause) {
            throw new MapperException(sql, um, pojo, cause);
        }

        int val;

        try {
            val = ps.executeUpdate();
        } catch (SQLException cause) {
            throw new EventstormSqlException("executeUpdate: cannot executeUpdate", cause);
        }

        if (val != 1) {
            throw new EventstormSqlException("executeUpdate: should update 1 element but updated [" + val + "]");
        }

    }

    protected final <E> void executeInsertAutoIncrement(String sql, InsertMapperWithAutoIncrement<E> im, E pojo) {

        PreparedStatement ps = database.transactionManager().context().write(sql);

        try {
            im.insert(ps, pojo);
        } catch (SQLException cause) {
            throw new MapperException(sql, im, pojo, cause);
        }

        int val;
        try {
            val = ps.executeUpdate();
        } catch (SQLException cause) {
            throw new EventstormSqlException("executeInsert: cannot Insert", cause);
        }
        if (val != 1) {
            throw new EventstormSqlException("executeInsert: should update 1 element but updated [" + val + "]");
        }

        try (ResultSet rs = ps.getGeneratedKeys()) {
            if (rs.next()) {
                im.setId(pojo, rs);
            }
        } catch (SQLException cause) {
            throw new M3RepositoryException(INSERT_GENERATED_KEYS, cause);
        }

    }

    protected final void executeDelete(String sql, PreparedStatementSetter pss) {

        if (LOGGER.isDebugEnabled()) {
            LOGGER.debug("DELETE : [{}]", sql);
        }

        PreparedStatement ps = database.transactionManager().context().write(sql);

        try {
            pss.set(ps);
        } catch (SQLException cause) {
            throw new M3PreparedStatementSetterException(sql, pss, cause);
        }

        try {
            int val = ps.executeUpdate();

            if (LOGGER.isDebugEnabled()) {
                LOGGER.debug("DELETE : number of element [{}]", val);
            }

        } catch (SQLException cause) {
            throw new EventstormSqlException("executeUpdate: cannot executeUpdate", cause);
        }

    }

    protected final <T> Page<T> executeSelectPage(String countSql, String sql, ResultSetMapper<T> mapper, Pageable pageable) {

        Long count = executeSelect(countSql, ps -> {

        }, ResultSetMappers.SINGLE_LONG);

        if (LOGGER.isDebugEnabled()) {
            LOGGER.debug("find count=[{}]", count);
        }

        if (count == null || count == 0) {
            return Page.empty();
        }

        return new PageImpl<>(stream(sql, ps -> {

        }, mapper), count, pageable);

    }

}
